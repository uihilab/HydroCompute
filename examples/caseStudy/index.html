<!DOCTYPE html>
<html lang="en">

<head>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
    crossorigin="anonymous"></script>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" onload="initHydrocompute() " src="../../src/hydrocompute.js"></script>
  <script type="module" onload="initHydroLang() " src="../../hydrolang/hydro.js"></script>

  <title>HydroCompute Case Study</title>
</head>

<body>
  <div class="row">
    <div class="col-3"></div>
    <div class="col-xl-12">
  <div class="container py-xl-9">
    <header class="pb-3 mb-4 border-bottom text-center lead"><b>Analysis on Streamflow Forecasting</b></header>
    <p>This case study retrieves and analyses on the fly streamflow data from different data sources within the Iowa
      City area. For each data source, it calculates the exponential moving average,
      simple moving average, a simple ARIMA process, and an autocorrelation function using the multiple engines and
      functions available through the hydrocompute framework.</p>
    <div class="row align-items-md-stretch">
      <div class="col-md-6">
        <div class="container p-2 bg-light rounded" id="DataGen">
          <h4 class="display-7">Data Retrieval</h4>
          <p class="lead">Queried from 1900s through today</p>
          <hr class="my-4">
          <label for="arraySel" class="form-label">Available Data Sources</label>
          <select class="form-select" name="sourceSelect" id="sourceSelect" onchange="onSelectSource()">
          </select>
          <label for="random">Select station(s)</label>
          <select class="form-select" multiple name="stationSelect" id="stationSelect">
          </select>
          <br>
          <button type="button" class="btn btn-outline-secondary" data-toggle="modal" data-target="#dataModal"
            onclick="onSelectStation()">Retrieve Stations</button>
        </div>
      </div>
      <div class="col-md-6" id="map">
      </div>
    </div>
    <div class="col-xl-12 py-2">
      <div class="container p-3 bg-white border rounded" id="resultViewer">
        <h4 class="display-11">Analysis and Results</h4>
        <p class="lead">Overview of results</p>
        <hr class="my-4">
        <div class="container rounded">
          <div class="row align-items-md-stretch">
            <div class="col-md-6 py-2">
              <h5 class="display-11 text-center">Retrieved Data</h5>
              <div id="paramTable"></div>
              <button class="btn btn-outline-secondary float-start">Clear Data</button>
              <button class="btn btn-outline-secondary float-end">Download
                Results</button>
            </div>
            <div class="col-md-6 py-2">
              <h5 class="display-11 text-center">Graphical output</h5>
              <div class="row align-items-sm-stretch">
                <div id="dashboard-div">
                  <div id="control-div"></div>
                  <div id="chart"></div>
                </div>
              </div>
              <div class="row align-items-sm-stretch">
                <div class="col-md-3 py-2" style="visibility: hidden;" id="result-div">
                  <label for="resultSelect" class="form-label">Change Source</label>
                  <select class="form-select" name="resultSelect" id="resultSelect"
                    onchange="populateRange()"></select>
                </div>
                <div class="col-md-3 py-2" style="visibility: hidden;" id="range-div">
                  <label for="rangeSelect" class="form-label">Change Range</label>
                  <select class="form-select" name="rangeSelect" id="rangeSelect"
                    onchange="visualizeDownloaded()"></select>
                </div>
              </div>
            </div>
            <br>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
</div>
  <script>
    const sources = ['MOPEX', 'NOAA GHCN', 'Global Rivers', 'USGS Daily Values'];
    let stations = [];
    let source_sites = [];
    let runningData;
    let computeReady = [];
    let stations_to_query = [];
    const initHydrocompute = () => {
      window.compute = new hydrocompute();
      //window.wasmcompute = new hydrocompute('wasm');
      let e = document.getElementById('sourceSelect')
      for (let source of sources) {
        e.add(new Option(`${source}`, `${source}`))
      }
    }

    const initHydroLang = () => {
      window.hydro = new Hydrolang();
      Promise.resolve(hydro.map.loader({ params: { maptype: 'osm' } }))
        .then(_ => hydro.map.renderMap({ args: { maptype: "osm", lat: 40, lon: -100 } }))
      let ele = document.getElementById('sourceSelect')
      ele.value = 'USGS Daily Values'
      ele.dispatchEvent(new Event('change'))
    }

    const onSelectSource = async () => {
      stations = [];
      let source = document.getElementById('sourceSelect').value;
      let station_select = document.getElementById('stationSelect')
      station_select.options.length = 0

      //Query locations using CUAHSI
      let params_fixed = {
        source: "waterOneFlow",
        datatype: "GetSitesByBoxObject",
        proxyServer: "local-proxy"
      };
      //Search query is done in the compute Iowa City Area, but can be expanded to the whole county
      let args_change = {
        sourceType: source,
        // west: "-91.6650",
        // south: "41.604",
        // east: "-91.416",
        // north: "41.714"
        west: "-91.6650",
        south: "41.604",
        east: "-91.416",
        north: "41.714"
      }

      const setStations = (s) => {
        for (let sm of s
          .GetSitesByBoxObjectResponse
          .sitesResponse
          .site) {
          stgSmt = {};
          stgSmt.name = sm.siteInfo.siteName;
          stgSmt.location = sm.siteInfo.geoLocation.geogLocation;
          stgSmt.siteCode = sm.siteInfo.siteCode;
          stations.push(stgSmt)
        }
        for (let station of stations) {
          station_select.add(new Option(`${station.name}`, `${station.siteCode}`))
          hydro.map.Layers({ args: { type: 'marker', output: `${station.siteCode}` }, data: [JSON.parse(station.location.latitude), JSON.parse(station.location.longitude)] })
        }
      }

      let x = await hydro.data.retrieve({ params: params_fixed, args: args_change })
      let y = setStations(await x)
      source_sites.push(await y)
    }

    const onSelectStation = async () => {
      computeReady = [];
      stations_to_query = [];
      let station_select = document.getElementById('stationSelect')
      let options = station_select && station_select.options;
      let opt;
      for (var i = 0, iLen = options.length; i < iLen; i++) {
        opt = options[i];

        if (opt.selected) {
          stations_to_query.push(opt.value || opt.text);
        }
      }
      console.log(stations_to_query)

      let usgs_query = {
        source: "usgs",
        datatype: "daily-values",
        proxyServer: "local-proxy"
      }

      let args_query = {
        //dates need to change here
        format: 'json',
        variable: '00060',
        startDt: '1900-01-01',
        endDt: (() => {
          let d = new Date(Date.now()); return date = [
            d.getFullYear(),
            ('0' + (d.getMonth() + 1)).slice(-2),
            ('0' + d.getDate()).slice(-2)
          ].join('-')
        })()
      }


      let executioner = []

      for (let station of stations_to_query) {
        args_query.site = station
        let exec = () => {
          return new Promise(async (resolve, reject) => {
            try {
              let x = await hydro.data.retrieve({ params: usgs_query, args: args_query })
              let y = cleanData(await x, station)
              resolve(await y)
            } catch (error) {
              reject(error)
            }
          })
        }
        executioner.push(exec())
      }
      Promise.resolve(await Promise.all(executioner)).then(_ => {
        tableParams()
        runCompute()
      })
    }

    const cleanData = (item, station) => {
      let new_item = hydro.data.transform({ params: { save: 'value' }, args: { keep: '["datetime", "value"]', type: 'ARR' }, data: item })
      new_item.forEach(arr => arr.shift())
      new_item[1] = new_item[1].map(y => JSON.parse(y))
      computeReady.push({ name: station, data: new_item })
    }

    const tableParams = () => {
      let colNames = ['Station', 'Number\nof\nRecords', 'Start\nDate', 'End\nDate']
      let rows = computeReady.length;
      let cols = colNames.length;
      let dv = document.getElementById('paramTable');
      (() => { while (dv.firstChild) dv.removeChild(dv.firstChild) })()

      let table = document.createElement('table');
      table.classList.add('table')

      let thead = document.createElement('thead')
      let headRow = document.createElement('tr')
      headRow.className = "text-center"

      for (var i = 0; i < cols; i++) {
        let th = document.createElement('th');
        th.appendChild(document.createTextNode(colNames[i]));
        headRow.appendChild(th)
      }
      thead.appendChild(headRow);

      let tbody = document.createElement('tbody');

      for (var i = 0; i < rows; i++) {
        let tr = document.createElement('tr')
        for (var j = 0; j < cols; j++) {
          let td = document.createElement('td')
          switch (j) {
            case 0:
              td.appendChild(document.createTextNode(computeReady[i].name));
              break;
            case 1:
              td.appendChild(document.createTextNode(computeReady[i].data[0].length));
              break;
            case 2:
              td.appendChild(document.createTextNode(computeReady[i].data[0][0].slice(0, 10)));
              break;
            case 3:
              td.appendChild(document.createTextNode(computeReady[i].data[0][computeReady[i].data[0].length - 1].slice(0, 10)));
              break;
            default:
              break;
          }
          tr.appendChild(td)
        }
        tbody.appendChild(tr)
      }
      tbody.className = "text-center"

      table.appendChild(thead);
      table.appendChild(tbody);
      table.id = 'param-tables'
      dv.appendChild(table)
    }

    const runCompute = async () => {

      populateResults()

      compute.availableData = []
      let jsFuns = ['expoMovingAverage', 'simpleMovingAverage', 'expoMovingAverage', 'simpleMovingAverage'];
      let cFuns = ['_arima', '_acf', 'exponentialMovingAverage'];

      for (let item of computeReady) {
        compute.data({ id: item.name, data: item.data[1] })
        //wasmcompute.data({ id: item.name, data: item.data[1] })
      }
      //for (let item of computeReady) {

      let x = Array.from({ length: cFuns.length }, (_, i) => [i - 1]);
      x[0] = [];
      let y = Array.from({ length: jsFuns.length }, (_, i) => [i - 1]);
      y[0] = [];

      compute.setEngine('javascript')

      await compute.run({
        callbacks: Array.from({ length: stations_to_query.length }, (_, i) => false),
        functions: Array.from({ length: stations_to_query.length }, (_, i) => jsFuns),
        dataIds: stations_to_query,
        dependencies: Array.from({ length: stations_to_query.length }, (_, i) => y), funcArgs: []
      });

      compute.setEngine('wasm')

      await compute.run({
        callbacks: Array.from({ length: stations_to_query.length }, (_, i) => false),
        functions: Array.from({ length: stations_to_query.length }, (_, i) => cFuns),
        dataIds: stations_to_query,
        dependencies: [], funcArgs: []
      })

      console.log('Run has finished.')
      //getandSeeResult()
    }

    const populateResults = () => {
      let resultSelect = document.getElementById('resultSelect');
      let resultDiv = document.getElementById('result-div');
      resultDiv.style.visibility = "visible"

      for (let query of computeReady) {
        resultSelect.add(new Option(`${query.name}`, `${query.name}`))
      }
      resultSelect.value = computeReady[0].name
      populateRange()
    }

    //
    const populateRange = () => {
      let optionSelect = document.getElementById('resultSelect').value;
      let rangePopulate = document.getElementById('rangeSelect')
      let rangeDiv = document.getElementById('range-div')
      rangePopulate.options.length = 0
      rangeDiv.style.visibility = "visible"


      for (let computeValue of computeReady) {
        if (computeValue.name === optionSelect) {
          let sliceSize = 1825
          console.log(sliceSize)
          for (let i = 0; i < computeValue.data[0].length; i += sliceSize) {
            let start = i;
            let end = Math.min(start + sliceSize, computeValue.data[0].length);
            let sliced = computeValue.data[0].slice(start, end);
            rangePopulate.add(new Option(`Dates between ${sliced[0].slice(0, 7)} through ${sliced[sliced.length - 1].slice(0, 7)}`, `[${start}, ${end}]`));
          }
          //visualizeDownloaded(computeReady[0], range)
          return
        }
      }
    }

    const visualizeDownloaded = () => {
      let optionSelect = document.getElementById('resultSelect').value;
      let rangePopulate = document.getElementById('rangeSelect').value;
      let engineResults = []

      let names = ['simpleMovingAvg', 'arima', 'acf', 'expoMovingAverage']

      let dateView, dataView, resultView
      let range = JSON.parse(rangePopulate)
      for (let val of computeReady) {
        if (val.name === optionSelect) {
          dateView = val.data[0].slice(range[0], range[1] + 1)
          dataView = val.data[1].slice(range[0], range[1] + 1)
        }
      }

      for (let result of compute.results('Simulation_1')) {
        if (result.name === optionSelect) {
          for (let r_1 of result.results) {
            engineResults.push(r_1.slice(range[0], range[1] + 1))
          }
        }

      }
      for (let result of compute.results('Simulation_2')) {
        if (result.name === optionSelect) {
          for (let r_2 of result.results) {
            engineResults.push(r_2.slice(range[0], range[1] + 1))
          }
        }
      }

      console.log(engineResults)


      google.charts.load('current', {
        callback: function () {

          let data = new google.visualization.DataTable();

          data.addColumn('date', 'Date');
          data.addColumn('number', `${optionSelect}`)

          for (let name of names) {
            data.addColumn('number', name)
          }

          for (let j = 0; j < dateView.length; j++) {
            data.addRow([new Date(dateView[j]), dataView[j], engineResults[0][j], engineResults[1][j], engineResults[2][j], engineResults[3][j]])
          }



          var chart = new google.visualization.ChartWrapper({
            chartType: 'LineChart',
            containerId: "chart",
            options: {
              theme: "maximized"
            }
          });

          var control = new google.visualization.ControlWrapper({
            controlType: "ChartRangeFilter",
            containerId: "control-div",
            options: {
              filterColumnIndex: 0
            }
          })

          google.visualization.events.addListener(control, 'statechange', () => {
            let state = control.getState();
            let view = new google.visualization.DataView(data);
            view.setRows(view.getFilteredRows([{ column: 0, minValue: state.range.start, maxValue: state.range.end }]))
          })

          let dashboard = new google.visualization.Dashboard(document.getElementById('dashboard-div'));
          dashboard.bind([control], [chart]);
          dashboard.draw(data)
        },
        packages: ['controls', 'corechart']
      })
    }

  </script>

</body>

</html>