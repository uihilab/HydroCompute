<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>wasm/wasm.worker.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="engine.html">engine</a><ul class='methods'><li data-type='method'><a href="engine.html#.availableScripts">availableScripts</a></li><li data-type='method'><a href="engine.html#.concurrentRun">concurrentRun</a></li><li data-type='method'><a href="engine.html#.initialize">initialize</a></li><li data-type='method'><a href="engine.html#.parallelRun">parallelRun</a></li><li data-type='method'><a href="engine.html#.run">run</a></li><li data-type='method'><a href="engine.html#.setEngine">setEngine</a></li><li data-type='method'><a href="engine.html#.stepRun">stepRun</a></li><li data-type='method'><a href="engine.html#.stop">stop</a></li><li data-type='method'><a href="engine.html#.taskRunner">taskRunner</a></li></ul></li><li><a href="EventBus.html">EventBus</a><ul class='methods'><li data-type='method'><a href="EventBus.html#clear">clear</a></li><li data-type='method'><a href="EventBus.html#emit">emit</a></li><li data-type='method'><a href="EventBus.html#off">off</a></li><li data-type='method'><a href="EventBus.html#on">on</a></li></ul></li><li><a href="hydroCompute.html">hydroCompute</a><ul class='methods'><li data-type='method'><a href="hydroCompute.html#availableEngines">availableEngines</a></li><li data-type='method'><a href="hydroCompute.html#availableResults">availableResults</a></li><li data-type='method'><a href="hydroCompute.html#availableSplits">availableSplits</a></li><li data-type='method'><a href="hydroCompute.html#currentEngine">currentEngine</a></li><li data-type='method'><a href="hydroCompute.html#data">data</a></li><li data-type='method'><a href="hydroCompute.html#engineScripts">engineScripts</a></li><li data-type='method'><a href="hydroCompute.html#getResTimes">getResTimes</a></li><li data-type='method'><a href="hydroCompute.html#getTotalTime">getTotalTime</a></li><li data-type='method'><a href="hydroCompute.html#isEngineSet">isEngineSet</a></li><li data-type='method'><a href="hydroCompute.html#makeId">makeId</a></li><li data-type='method'><a href="hydroCompute.html#results">results</a></li><li data-type='method'><a href="hydroCompute.html#run">run</a></li><li data-type='method'><a href="hydroCompute.html#setEngine">setEngine</a></li><li data-type='method'><a href="hydroCompute.html#setResults">setResults</a></li><li data-type='method'><a href="hydroCompute.html#setTotalTime">setTotalTime</a></li><li data-type='method'><a href="hydroCompute.html#stop">stop</a></li></ul></li><li><a href="threadManager.html">threadManager</a><ul class='methods'><li data-type='method'><a href="threadManager.html#.createWorkerThread">createWorkerThread</a></li><li data-type='method'><a href="threadManager.html#.initializeWorkerThread">initializeWorkerThread</a></li><li data-type='method'><a href="threadManager.html#.killAllWorkers">killAllWorkers</a></li><li data-type='method'><a href="threadManager.html#.resetWorkers">resetWorkers</a></li><li data-type='method'><a href="threadManager.html#.stop">stop</a></li></ul><ul class='members'><li data-type='method'><a href="threadManager.html#.execTimes">execTimes</a></li></ul></li><li><a href="WebRTC.html">WebRTC</a><ul class='methods'><li data-type='method'><a href="WebRTC.html#.createAnswer">createAnswer</a></li><li data-type='method'><a href="WebRTC.html#.createOfferDescription">createOfferDescription</a></li><li data-type='method'><a href="WebRTC.html#.initialize">initialize</a></li><li data-type='method'><a href="WebRTC.html#.onAvailableChannel">onAvailableChannel</a></li><li data-type='method'><a href="WebRTC.html#.oncloseHost">oncloseHost</a></li><li data-type='method'><a href="WebRTC.html#.oncloseReceiver">oncloseReceiver</a></li><li data-type='method'><a href="WebRTC.html#.openConnection">openConnection</a></li><li data-type='method'><a href="WebRTC.html#.restartDataChannel">restartDataChannel</a></li><li data-type='method'><a href="WebRTC.html#.run">run</a></li><li data-type='method'><a href="WebRTC.html#.sendData">sendData</a></li><li data-type='method'><a href="WebRTC.html#.setConnection">setConnection</a></li><li data-type='method'><a href="WebRTC.html#.setDataChannel">setDataChannel</a></li><li data-type='method'><a href="WebRTC.html#.setOfferDescription">setOfferDescription</a></li><li data-type='method'><a href="WebRTC.html#.submitArray">submitArray</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-kernels.html">kernels</a></li><li><a href="Worker.module_GPUWorker.html">GPUWorker</a></li><li><a href="Workers.module_JSWorker.html">JSWorker</a></li><li><a href="Workers.module_PythonWorker.html">PythonWorker</a></li><li><a href="Workers.module_WASMWorker.html">WASMWorker</a><ul class='methods'><li data-type='method'><a href="Workers.module_WASMWorker.html#~getModuleFromDB">getModuleFromDB</a></li><li data-type='method'><a href="Workers.module_WASMWorker.html#~handleC">handleC</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="dbUtils.html">dbUtils</a></li><li><a href="ErrorTypes%250AUsed%2520throughout%2520the%2520libary%2520to%2520assert%2520the%2520types%2520of%2520errors%2520found.html">ErrorTypes
Used throughout the libary to assert the types of errors found</a></li><li><a href="globalUtils.html">globalUtils</a><ul class='methods'><li data-type='method'><a href="globalUtils.html#.arrayChanger">arrayChanger</a></li><li data-type='method'><a href="globalUtils.html#.concatArrays">concatArrays</a></li><li data-type='method'><a href="globalUtils.html#.DAG">DAG</a></li><li data-type='method'><a href="globalUtils.html#.dataCloner">dataCloner</a></li><li data-type='method'><a href="globalUtils.html#.flattenFloat32Array">flattenFloat32Array</a></li><li data-type='method'><a href="globalUtils.html#.getPerformanceMeasures">getPerformanceMeasures</a></li><li data-type='method'><a href="globalUtils.html#.importJSONdata">importJSONdata</a></li><li data-type='method'><a href="globalUtils.html#.IndexedDAG">IndexedDAG</a></li></ul></li><li><a href="gpuScripts.html">gpuScripts</a><ul class='members'><li data-type='method'><a href="gpuScripts.html#.gpuScripts">gpuScripts</a></li><li data-type='method'><a href="gpuScripts.html#.matrixUtils_gpu">matrixUtils_gpu</a></li></ul></li><li><a href="gpuUtils.html">gpuUtils</a><ul class='members'><li data-type='method'><a href="gpuUtils.html#.bindGroup">bindGroup</a></li><li data-type='method'><a href="gpuUtils.html#.bindLayout">bindLayout</a></li><li data-type='method'><a href="gpuUtils.html#.bufferCreator">bufferCreator</a></li><li data-type='method'><a href="gpuUtils.html#.bufferDestroyer">bufferDestroyer</a></li><li data-type='method'><a href="gpuUtils.html#.computingPipelines">computingPipelines</a></li><li data-type='method'><a href="gpuUtils.html#.deviceConnect">deviceConnect</a></li><li data-type='method'><a href="gpuUtils.html#.dispatchers">dispatchers</a></li><li data-type='method'><a href="gpuUtils.html#.exports.matrixChanger">exports.matrixChanger</a></li><li data-type='method'><a href="gpuUtils.html#.groupEntry">groupEntry</a></li><li data-type='method'><a href="gpuUtils.html#.layoutEntry">layoutEntry</a></li><li data-type='method'><a href="gpuUtils.html#.matrixSize">matrixSize</a></li><li data-type='method'><a href="gpuUtils.html#.resultHolder">resultHolder</a></li><li data-type='method'><a href="gpuUtils.html#.shaderModule">shaderModule</a></li></ul></li><li><a href="jsScripts.html">jsScripts</a><ul class='members'><li data-type='method'><a href="jsScripts.html#.matrixUtils_js">matrixUtils_js</a></li><li data-type='method'><a href="jsScripts.html#.timeSeries_js">timeSeries_js</a></li></ul></li><li><a href="splits.html">splits</a><ul class='methods'><li data-type='method'><a href="splits.html#.divideIntoSubmatrices">divideIntoSubmatrices</a></li><li data-type='method'><a href="splits.html#.join">join</a></li><li data-type='method'><a href="splits.html#.main">main</a></li><li data-type='method'><a href="splits.html#.split1DArray">split1DArray</a></li><li data-type='method'><a href="splits.html#.splitMatrix">splitMatrix</a></li><li data-type='method'><a href="splits.html#.splitmDArray">splitmDArray</a></li></ul></li><li><a href="WASMUtils.html">WASMUtils</a><ul class='methods'><li data-type='method'><a href="WASMUtils.html#._location">_location</a></li><li data-type='method'><a href="WASMUtils.html#.ASModule">ASModule</a></li><li data-type='method'><a href="WASMUtils.html#.avScripts">avScripts</a></li><li data-type='method'><a href="WASMUtils.html#.CModule">CModule</a></li><li data-type='method'><a href="WASMUtils.html#.filterFunctionKeys">filterFunctionKeys</a></li><li data-type='method'><a href="WASMUtils.html#.getAllModules">getAllModules</a></li><li data-type='method'><a href="WASMUtils.html#.loadModule">loadModule</a></li></ul><ul class='members'><li data-type='method'><a href="WASMUtils.html#.AScriptUtils">AScriptUtils</a></li><li data-type='method'><a href="WASMUtils.html#.ASUtils">ASUtils</a></li><li data-type='method'><a href="WASMUtils.html#.availableScripts">availableScripts</a></li><li data-type='method'><a href="WASMUtils.html#.CUtils">CUtils</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#bindJsToR">bindJsToR</a></li><li><a href="global.html#DB_CONFIG">DB_CONFIG</a></li><li><a href="global.html#getDatabaseConfig">getDatabaseConfig</a></li><li><a href="global.html#getDatabaseName">getDatabaseName</a></li><li><a href="global.html#getDatabaseVersion">getDatabaseVersion</a></li><li><a href="global.html#getDataFromIndexedDB">getDataFromIndexedDB</a></li><li><a href="global.html#getPyodide">getPyodide</a></li><li><a href="global.html#getStoreConfig">getStoreConfig</a></li><li><a href="global.html#getWebR">getWebR</a></li><li><a href="global.html#gzipToBase64">gzipToBase64</a></li><li><a href="global.html#isGzipped">isGzipped</a></li><li><a href="global.html#jsToPython">jsToPython</a></li><li><a href="global.html#loadRPackages">loadRPackages</a></li><li><a href="global.html#openDatabase">openDatabase</a></li><li><a href="global.html#pakoLib">pakoLib</a></li><li><a href="global.html#parseXMLSimple">parseXMLSimple</a></li><li><a href="global.html#parseXMLToJSON">parseXMLToJSON</a></li><li><a href="global.html#processDataForXML">processDataForXML</a></li><li><a href="global.html#pythonToJs">pythonToJs</a></li><li><a href="global.html#reassembleChunksFromStore">reassembleChunksFromStore</a></li><li><a href="global.html#resolveDependency">resolveDependency</a></li><li><a href="global.html#storeExistsInSchema">storeExistsInSchema</a></li><li><a href="global.html#storeResultInIndexedDB">storeResultInIndexedDB</a></li><li><a href="global.html#toColumnar">toColumnar</a></li><li><a href="global.html#verifyDatabaseAccess">verifyDatabaseAccess</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">wasm/wasm.worker.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//import { AScriptUtils } from '../utils/ascript-utils.js';
import { getPerformanceMeasures } from "../core/utils/globalUtils.js";
//import { splits } from '../utils/splits.js';
import { openDatabase } from '../core/utils/db-config.js';

/**
 * @description Web worker script for executing WASM computations
 * @module WebWorker
 * @memberof Workers
 * @name WASMWorker
 */
self.onmessage = async (e) => {

  performance.mark("start-script");
  let { id, step, data: inputData, uniqueId, dbConfig } = e.data;

  // Send status update
  if (uniqueId) {
    self.postMessage({
      type: 'status',
      itemId: uniqueId,
      status: 'running'
    });
  }

  let result = null;

  try {
    // Get the item settings from the database
    const db = await openDatabase();
    const settingsStore = db.transaction('settings', 'readonly').objectStore('settings');
    const settings = await new Promise((resolve, reject) => {
      const request = settingsStore.get(uniqueId);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });

    if (!settings) {
      throw new Error(`Settings not found for item ${uniqueId}`);
    }

    // Extract WASM-specific settings
    const { moduleId, functionName, memoryPages } = settings.arguments;

    // Get the module from IndexedDB
    const module = await getModuleFromDB(moduleId);
    if (!module) {
      throw new Error(`Module ${moduleId} not found in database`);
    }

    // Process input data if provided
    let processedData = null;
    if (inputData) {
      processedData = new Float32Array(inputData);
      //processedData = splits.split1DArray({ data, n: data.length });
    }

    performance.mark("start-function");
    result = handleC(null, functionName, processedData, module);
    performance.mark("end-function");

    let getPerformance = getPerformanceMeasures();

    // Store the result using the provided database config
    if (dbConfig &amp;&amp; uniqueId) {
      const resultData = {
        id: uniqueId,
        data: result,
        status: 'completed',
        timestamp: new Date().toISOString()
      };

      const db = await openDatabase();
      const resultsStore = db.transaction('results', 'readwrite').objectStore('results');
      await new Promise((resolve, reject) => {
        const request = resultsStore.put(resultData);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    self.postMessage(
      {
        id,
        results: result,
        step,
        ...getPerformance,
      },
      [result]
    );

    // Update status
    if (uniqueId) {
      self.postMessage({
        type: 'status',
        itemId: uniqueId,
        status: 'completed'
      });
    }
  } catch (error) {
    console.error(`Error executing WASM item ${uniqueId}:`, error);

    // Update status with error
    if (uniqueId) {
      self.postMessage({
        type: 'status',
        itemId: uniqueId,
        status: 'error',
        error: error.message
      });
    }

    self.postMessage({
      type: 'error',
      error: error.message,
      id
    });
  }
};

/**
 * Retrieves a module from IndexedDB using the provided database utility
 * @param {string} moduleId - The ID of the module in the database
 * @returns {Promise&lt;WebAssembly.Module>} The instantiated module
 */
// async function getModuleFromDB(moduleId) {
//     if (!moduleId) {
//         throw new Error('No module ID provided');
//     }

async function getModuleFromDB(moduleId) {
  if (!moduleId) throw new Error('No module ID provided');

  const db = await openDatabase();
  const store = db.transaction('wasmModules', 'readonly').objectStore('wasmModules');

  const moduleData = await new Promise((resolve, reject) => {
    const request = store.get(moduleId);
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });

  if (!moduleData) throw new Error(`Module ${moduleId} not found in database`);

  const memory = new WebAssembly.Memory({
    initial: moduleData.memoryPages || 1,
    maximum: moduleData.memoryPages || 1,
  });

  // Construct the base module object
  const baseModule = {
    wasmMemory: memory,
    print: (text) => console.log(text),
    printErr: (text) => console.error(text),
  };

  if (moduleData.wasmBlob) {
    baseModule.wasmBinary = await moduleData.wasmBlob.arrayBuffer();
  }

  // Load the JS glue code from blob
  const jsCodeText = await moduleData.blob.text();
  const blob = new Blob([jsCodeText], { type: 'application/javascript' });
  const blobURL = URL.createObjectURL(blob);

  // Inject baseModule globally in case of legacy style
  globalThis.Module = baseModule;

  try {
    // Import the Emscripten glue code
    importScripts(blobURL);

    // Check if MODULARIZE-style (createModule function)
    if (typeof createModule === 'function') {
      const mod = await createModule(baseModule);
      URL.revokeObjectURL(blobURL);
      return mod;
    }

    // Otherwise, wait for non-MODULARIZE global `Module`
    if (typeof Module !== 'undefined' &amp;&amp; Module instanceof Object) {
      if (typeof Module.then === 'function') {
        const mod = await Module;
        URL.revokeObjectURL(blobURL);
        return mod;
      }

      // Wait for runtime init if needed
      await new Promise((resolve) => {
        if (Module.calledRun) {
          resolve();
        } else {
          Module.onRuntimeInitialized = resolve;
        }
      });

      URL.revokeObjectURL(blobURL);
      return Module;
    }

    throw new Error('Could not detect Emscripten module style (MODULARIZE or legacy)');

  } catch (err) {
    URL.revokeObjectURL(blobURL);
    console.error('Error loading module script:', err);
    throw err;
  }
}
//     try {
//         const db = await openDatabase();
//         const store = db.transaction('wasmModules', 'readonly').objectStore('wasmModules');

//         const moduleData = await new Promise((resolve, reject) => {
//             const request = store.get(moduleId);
//             request.onsuccess = () => resolve(request.result);
//             request.onerror = () => reject(request.error);
//         });

//         if (!moduleData) {
//             throw new Error(`Module ${moduleId} not found in database`);
//         }

//         // Create base memory configuration
//         const memory = new WebAssembly.Memory({
//             initial: moduleData.memoryPages || 1,
//             maximum: moduleData.memoryPages || 1
//         });

//         // Case 1: Pure WASM module
//         if (moduleData.contentType === 'application/wasm') {
//             const wasmBuffer = await moduleData.blob.arrayBuffer();
//             const importObject = {
//                 env: {
//                     memory,
//                     abort: (msg, file, line, column) => {
//                         console.error(`WASM abort: ${msg} at ${file}:${line}:${column}`);
//                     }
//                 }
//             };

//             const instance = await WebAssembly.instantiate(wasmBuffer, importObject);
//             return instance.instance.exports;
//         }

//         // Case 2 &amp; 3: JS module (either with WASM or standalone)
//         const jsCode = await moduleData.blob.text();

//         // Create a base Module object that Emscripten expects
//         const baseModule = {
//             wasmMemory: memory,
//             wasmBinary: null,
//             print: (text) => console.log(text),
//             printErr: (text) => console.error(text),
//             locateFile: (path) => {
//                 // If this is a WASM file and we have a wasmUrl, use it
//                 if (path.endsWith('.wasm') &amp;&amp; moduleData.wasmUrl) {
//                     return moduleData.wasmUrl;
//                 }
//                 return path;
//             }
//         };

//         // If we have a WASM blob, add it to the module
//         if (moduleData.wasmBlob) {
//             baseModule.wasmBinary = await moduleData.wasmBlob.arrayBuffer();
//         }

//         // Create script URL from the JS blob
//         const scriptUrl = moduleData.url;

//         // Create a module script that will run in the worker context
//         const moduleScript = `
//             let Module = ${JSON.stringify(baseModule)};
//             ${jsCode}
//             Module;
//         `;

//         // Execute the module script
//         const moduleFunc = new Function('return ' + moduleScript);
//         const Module = moduleFunc();

//         // If this is an Emscripten module, it might need initialization
//         if (typeof Module.then === 'function') {
//             return await Module;
//         }

//         return Module;

//     } catch (error) {
//         console.error('Error getting WASM module:', error);
//         throw error;
//     }
//   });
// }


/**
 * @method handleC
 * @description function for handling parametrization of C-based Web Assembly functions
 * @param {String} moduleName - name of the module running the script
 * @param {String} funcName - name of the function to run in the module
 * @param {Array} data - data object to use for the run
 * @param {Object} module - module run containing the memory alloc functions
 * @returns {ArrayBuffer} - result buffer to be sent back from the worker
 */
const handleC = (moduleName = null, functionName = null, data, module) => {
  let stgRes = null;
  let ptrs = [];
  let r_ptr = 0;
  let outputData = null;
  let d = null;

  const bytes = Float32Array.BYTES_PER_ELEMENT;
  let inputData = data;
  let inputCount = data ? data.length : 0;

  try {
    // If no data is provided, just call the function with no arguments
    if (!data || inputCount === 0) {
      // Call the function without arguments
      r_ptr = module[functionName || '_mainFunc']();
      // Create a small result buffer
      stgRes = new ArrayBuffer(4);
      return stgRes;
    }

    let len = inputData[0].length;

    // Check if we're dealing with a JS-WASM module or pure WASM
    const isJsWasm = typeof module._malloc === 'function';
    const createMemFunc = isJsWasm ? '_malloc' : '_createMem';
    const destroyMemFunc = isJsWasm ? '_free' : '_destroy';

    r_ptr = module[createMemFunc](len * bytes);

    // Allocate memory for input and output arrays
    for (let i = 0; i &lt; inputCount; i++) {
      ptrs.push(module[createMemFunc](len * bytes));
    }

    // Copy input data to memory
    for (let j = 0; j &lt; ptrs.length; j++) {
      module.HEAPF32.set(inputData[j], ptrs[j] / bytes);
    }

    // Call the C function and measure execution time
    performance.mark("start-function");
    if (moduleName === "matrixUtils_c") {
      module[functionName](...ptrs, r_ptr, Math.sqrt(len));
    } else if (moduleName === null) {
      module["_mainFunc"](...ptrs, r_ptr, len);
    } else {
      module[functionName](...ptrs, r_ptr, len);
    }
    performance.mark("end-function");

    // Copy result data from memory and clean up memory
    d = Array.from(new Float32Array(module.HEAPF32.buffer, r_ptr, len));
    outputData = new Float32Array(d);
    stgRes = new ArrayBuffer(outputData.buffer.byteLength);
    new Float32Array(stgRes).set(new Float32Array(outputData.buffer));
  } finally {
    // Clean up allocated memory
    for (let k of ptrs) {
      module[destroyMemFunc](k);
    }
    if (r_ptr) {
      module[destroyMemFunc](r_ptr);
    }
    outputData = null;
    r_ptr = null;
  }
  return stgRes;
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Jan 12 2026 21:01:45 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
