<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>R/webr.worker.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="engine.html">engine</a><ul class='methods'><li data-type='method'><a href="engine.html#.availableScripts">availableScripts</a></li><li data-type='method'><a href="engine.html#.concurrentRun">concurrentRun</a></li><li data-type='method'><a href="engine.html#.initialize">initialize</a></li><li data-type='method'><a href="engine.html#.parallelRun">parallelRun</a></li><li data-type='method'><a href="engine.html#.run">run</a></li><li data-type='method'><a href="engine.html#.setEngine">setEngine</a></li><li data-type='method'><a href="engine.html#.stepRun">stepRun</a></li><li data-type='method'><a href="engine.html#.stop">stop</a></li><li data-type='method'><a href="engine.html#.taskRunner">taskRunner</a></li></ul></li><li><a href="EventBus.html">EventBus</a><ul class='methods'><li data-type='method'><a href="EventBus.html#clear">clear</a></li><li data-type='method'><a href="EventBus.html#emit">emit</a></li><li data-type='method'><a href="EventBus.html#off">off</a></li><li data-type='method'><a href="EventBus.html#on">on</a></li></ul></li><li><a href="hydroCompute.html">hydroCompute</a><ul class='methods'><li data-type='method'><a href="hydroCompute.html#availableEngines">availableEngines</a></li><li data-type='method'><a href="hydroCompute.html#availableResults">availableResults</a></li><li data-type='method'><a href="hydroCompute.html#availableSplits">availableSplits</a></li><li data-type='method'><a href="hydroCompute.html#currentEngine">currentEngine</a></li><li data-type='method'><a href="hydroCompute.html#data">data</a></li><li data-type='method'><a href="hydroCompute.html#engineScripts">engineScripts</a></li><li data-type='method'><a href="hydroCompute.html#getResTimes">getResTimes</a></li><li data-type='method'><a href="hydroCompute.html#getTotalTime">getTotalTime</a></li><li data-type='method'><a href="hydroCompute.html#isEngineSet">isEngineSet</a></li><li data-type='method'><a href="hydroCompute.html#makeId">makeId</a></li><li data-type='method'><a href="hydroCompute.html#results">results</a></li><li data-type='method'><a href="hydroCompute.html#run">run</a></li><li data-type='method'><a href="hydroCompute.html#setEngine">setEngine</a></li><li data-type='method'><a href="hydroCompute.html#setResults">setResults</a></li><li data-type='method'><a href="hydroCompute.html#setTotalTime">setTotalTime</a></li><li data-type='method'><a href="hydroCompute.html#stop">stop</a></li></ul></li><li><a href="threadManager.html">threadManager</a><ul class='methods'><li data-type='method'><a href="threadManager.html#.createWorkerThread">createWorkerThread</a></li><li data-type='method'><a href="threadManager.html#.initializeWorkerThread">initializeWorkerThread</a></li><li data-type='method'><a href="threadManager.html#.killAllWorkers">killAllWorkers</a></li><li data-type='method'><a href="threadManager.html#.resetWorkers">resetWorkers</a></li><li data-type='method'><a href="threadManager.html#.stop">stop</a></li></ul><ul class='members'><li data-type='method'><a href="threadManager.html#.execTimes">execTimes</a></li></ul></li><li><a href="WebRTC.html">WebRTC</a><ul class='methods'><li data-type='method'><a href="WebRTC.html#.createAnswer">createAnswer</a></li><li data-type='method'><a href="WebRTC.html#.createOfferDescription">createOfferDescription</a></li><li data-type='method'><a href="WebRTC.html#.initialize">initialize</a></li><li data-type='method'><a href="WebRTC.html#.onAvailableChannel">onAvailableChannel</a></li><li data-type='method'><a href="WebRTC.html#.oncloseHost">oncloseHost</a></li><li data-type='method'><a href="WebRTC.html#.oncloseReceiver">oncloseReceiver</a></li><li data-type='method'><a href="WebRTC.html#.openConnection">openConnection</a></li><li data-type='method'><a href="WebRTC.html#.restartDataChannel">restartDataChannel</a></li><li data-type='method'><a href="WebRTC.html#.run">run</a></li><li data-type='method'><a href="WebRTC.html#.sendData">sendData</a></li><li data-type='method'><a href="WebRTC.html#.setConnection">setConnection</a></li><li data-type='method'><a href="WebRTC.html#.setDataChannel">setDataChannel</a></li><li data-type='method'><a href="WebRTC.html#.setOfferDescription">setOfferDescription</a></li><li data-type='method'><a href="WebRTC.html#.submitArray">submitArray</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-kernels.html">kernels</a></li><li><a href="Worker.module_GPUWorker.html">GPUWorker</a></li><li><a href="Workers.module_JSWorker.html">JSWorker</a></li><li><a href="Workers.module_PythonWorker.html">PythonWorker</a></li><li><a href="Workers.module_WASMWorker.html">WASMWorker</a><ul class='methods'><li data-type='method'><a href="Workers.module_WASMWorker.html#~getModuleFromDB">getModuleFromDB</a></li><li data-type='method'><a href="Workers.module_WASMWorker.html#~handleC">handleC</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="dbUtils.html">dbUtils</a></li><li><a href="ErrorTypes%250AUsed%2520throughout%2520the%2520libary%2520to%2520assert%2520the%2520types%2520of%2520errors%2520found.html">ErrorTypes
Used throughout the libary to assert the types of errors found</a></li><li><a href="globalUtils.html">globalUtils</a><ul class='methods'><li data-type='method'><a href="globalUtils.html#.arrayChanger">arrayChanger</a></li><li data-type='method'><a href="globalUtils.html#.concatArrays">concatArrays</a></li><li data-type='method'><a href="globalUtils.html#.DAG">DAG</a></li><li data-type='method'><a href="globalUtils.html#.dataCloner">dataCloner</a></li><li data-type='method'><a href="globalUtils.html#.flattenFloat32Array">flattenFloat32Array</a></li><li data-type='method'><a href="globalUtils.html#.getPerformanceMeasures">getPerformanceMeasures</a></li><li data-type='method'><a href="globalUtils.html#.importJSONdata">importJSONdata</a></li><li data-type='method'><a href="globalUtils.html#.IndexedDAG">IndexedDAG</a></li></ul></li><li><a href="gpuScripts.html">gpuScripts</a><ul class='members'><li data-type='method'><a href="gpuScripts.html#.gpuScripts">gpuScripts</a></li><li data-type='method'><a href="gpuScripts.html#.matrixUtils_gpu">matrixUtils_gpu</a></li></ul></li><li><a href="gpuUtils.html">gpuUtils</a><ul class='members'><li data-type='method'><a href="gpuUtils.html#.bindGroup">bindGroup</a></li><li data-type='method'><a href="gpuUtils.html#.bindLayout">bindLayout</a></li><li data-type='method'><a href="gpuUtils.html#.bufferCreator">bufferCreator</a></li><li data-type='method'><a href="gpuUtils.html#.bufferDestroyer">bufferDestroyer</a></li><li data-type='method'><a href="gpuUtils.html#.computingPipelines">computingPipelines</a></li><li data-type='method'><a href="gpuUtils.html#.deviceConnect">deviceConnect</a></li><li data-type='method'><a href="gpuUtils.html#.dispatchers">dispatchers</a></li><li data-type='method'><a href="gpuUtils.html#.exports.matrixChanger">exports.matrixChanger</a></li><li data-type='method'><a href="gpuUtils.html#.groupEntry">groupEntry</a></li><li data-type='method'><a href="gpuUtils.html#.layoutEntry">layoutEntry</a></li><li data-type='method'><a href="gpuUtils.html#.matrixSize">matrixSize</a></li><li data-type='method'><a href="gpuUtils.html#.resultHolder">resultHolder</a></li><li data-type='method'><a href="gpuUtils.html#.shaderModule">shaderModule</a></li></ul></li><li><a href="jsScripts.html">jsScripts</a><ul class='members'><li data-type='method'><a href="jsScripts.html#.matrixUtils_js">matrixUtils_js</a></li><li data-type='method'><a href="jsScripts.html#.timeSeries_js">timeSeries_js</a></li></ul></li><li><a href="splits.html">splits</a><ul class='methods'><li data-type='method'><a href="splits.html#.divideIntoSubmatrices">divideIntoSubmatrices</a></li><li data-type='method'><a href="splits.html#.join">join</a></li><li data-type='method'><a href="splits.html#.main">main</a></li><li data-type='method'><a href="splits.html#.split1DArray">split1DArray</a></li><li data-type='method'><a href="splits.html#.splitMatrix">splitMatrix</a></li><li data-type='method'><a href="splits.html#.splitmDArray">splitmDArray</a></li></ul></li><li><a href="WASMUtils.html">WASMUtils</a><ul class='methods'><li data-type='method'><a href="WASMUtils.html#._location">_location</a></li><li data-type='method'><a href="WASMUtils.html#.ASModule">ASModule</a></li><li data-type='method'><a href="WASMUtils.html#.avScripts">avScripts</a></li><li data-type='method'><a href="WASMUtils.html#.CModule">CModule</a></li><li data-type='method'><a href="WASMUtils.html#.filterFunctionKeys">filterFunctionKeys</a></li><li data-type='method'><a href="WASMUtils.html#.getAllModules">getAllModules</a></li><li data-type='method'><a href="WASMUtils.html#.loadModule">loadModule</a></li></ul><ul class='members'><li data-type='method'><a href="WASMUtils.html#.AScriptUtils">AScriptUtils</a></li><li data-type='method'><a href="WASMUtils.html#.ASUtils">ASUtils</a></li><li data-type='method'><a href="WASMUtils.html#.availableScripts">availableScripts</a></li><li data-type='method'><a href="WASMUtils.html#.CUtils">CUtils</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#DB_CONFIG">DB_CONFIG</a></li><li><a href="global.html#getDatabaseConfig">getDatabaseConfig</a></li><li><a href="global.html#getDatabaseName">getDatabaseName</a></li><li><a href="global.html#getDatabaseVersion">getDatabaseVersion</a></li><li><a href="global.html#getDataFromIndexedDB">getDataFromIndexedDB</a></li><li><a href="global.html#getStoreConfig">getStoreConfig</a></li><li><a href="global.html#openDatabase">openDatabase</a></li><li><a href="global.html#parseXMLSimple">parseXMLSimple</a></li><li><a href="global.html#parseXMLToJSON">parseXMLToJSON</a></li><li><a href="global.html#processDataForXML">processDataForXML</a></li><li><a href="global.html#reassembleChunksFromStore">reassembleChunksFromStore</a></li><li><a href="global.html#storeExistsInSchema">storeExistsInSchema</a></li><li><a href="global.html#storeResultInIndexedDB">storeResultInIndexedDB</a></li><li><a href="global.html#verifyDatabaseAccess">verifyDatabaseAccess</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">R/webr.worker.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { getPerformanceMeasures } from "../core/utils/globalUtils.js";
import { openDatabase } from "../core/utils/db-config.js";
import {
    verifyDatabaseAccess,
    getDataFromIndexedDB,
    storeResultInIndexedDB,
    prepareDataForStorage
} from "../core/utils/db-utils.js";

// WebR instance
let webRInstance = null;

// Helper to determine if we are in a worker context
const isWorker = typeof importScripts === "function";
console.log('[R Worker] Worker loaded successfully.');


/**
 * Initialize WebR instance
 * @ignore
 * @returns {Promise} WebR instance
 */
async function getWebR() {
    if (!webRInstance) {
        console.log('Loading WebR in worker...');
        try {
            // Import WebR dynamically
            const { WebR } = await import('https://webr.r-wasm.org/v0.3.3/webr.mjs');

            const webR = new WebR({
                // interactive: false 
            });

            await webR.init();
            console.log('WebR loaded successfully');
            webRInstance = webR;
        } catch (error) {
            console.error('Error loading WebR:', error);
            throw new Error(`Failed to load WebR: ${error.message}`);
        }
    }
    return webRInstance;
}

/**
 * Install and load R packages
 * @ignore
 * @param {Array&lt;string>} packages - List of package names
 * @param {Object} webR - WebR instance
 */
async function loadRPackages(packages, webR) {
    if (!packages || packages.length === 0) return;

    console.log(`Loading R packages: ${packages.join(', ')}`);

    // Mount the implementation of install.packages (uses webr repo)
    await webR.installPackages(packages);

    // Load them using library()
    for (const pkg of packages) {
        try {
            await webR.evalR(`library(${pkg})`);
            console.log(`Library ${pkg} loaded.`);
        } catch (e) {
            console.error(`Failed to load library ${pkg}:`, e);
            throw e;
        }
    }
}

/**
 * Convert JavaScript data to R objects and bind them to the global environment
 * @ignore
 * @param {any} jsData - JavaScript data
 * @param {string} bindName - Name of the variable in R
 * @param {Object} webR - WebR instance
 */
async function bindJsToR(jsData, bindName, webR) {
    try {
        console.log(`Binding JS data to R variable '${bindName}'...`, {
            type: typeof jsData,
            isArray: Array.isArray(jsData),
            constructor: jsData?.constructor?.name
        });

        // 1. TypedArrays (Efficient Direct Binding)
        // WebR supports creating R objects directly from TypedArrays
        if (jsData instanceof Float32Array || jsData instanceof Float64Array) {
            // Treat as double vector
            // webR.RObject can wrap these or we can use specific constructors
            // Current WebR API favors: new webR.toJs or binding via shelter?
            // Simplest robust way: 
            await webR.objs.globalEnv.bind(bindName, jsData);
        }
        else if (jsData instanceof Int32Array || jsData instanceof Int16Array || jsData instanceof Int8Array) {
            // Treat as integer vector
            await webR.objs.globalEnv.bind(bindName, jsData);
        }
        else if (jsData instanceof Uint8Array || jsData instanceof Uint16Array || jsData instanceof Uint32Array) {
            // Treat as integer/double vector depending on precision, usually double safe
            await webR.objs.globalEnv.bind(bindName, jsData);
        }
        // 2. Standard Arrays (Numeric/String/Boolean)
        else if (Array.isArray(jsData)) {
            // Check content type briefly
            if (jsData.length > 0 &amp;&amp; typeof jsData[0] === 'number') {
                // Numeric array
                await webR.objs.globalEnv.bind(bindName, jsData);
            } else if (jsData.length > 0 &amp;&amp; typeof jsData[0] === 'string') {
                // String array
                await webR.objs.globalEnv.bind(bindName, jsData);
            } else {
                // Mixed or objects -> pass as generic binding
                await webR.objs.globalEnv.bind(bindName, jsData);
            }
        }
        // 3. Objects (DataFrames / Lists)
        else if (typeof jsData === 'object' &amp;&amp; jsData !== null) {
            // Bind as Named List (equivalent to JS Object)
            await webR.objs.globalEnv.bind(bindName, jsData);
        }
        // 4. Primitives
        else {
            await webR.objs.globalEnv.bind(bindName, jsData);
        }

        console.log(`Successfully bound '${bindName}'`);

    } catch (error) {
        console.error(`Error binding data to R variable '${bindName}':`, error);
        throw error;
    }
}

/**
 * Helper to convert Array of Objects (Row-oriented) to Object of Arrays (Columnar)
 * @ignore
 * @param {Array} data - Input array of objects
 * @returns {Object} Columnar data
 */
function toColumnar(data) {
    if (!Array.isArray(data) || data.length === 0 || typeof data[0] !== 'object' || data[0] === null) {
        return data;
    }

    const keys = Object.keys(data[0]);
    const columnarData = {};

    // Initialize arrays for each key
    keys.forEach(key => {
        columnarData[key] = [];
    });

    // Populate arrays
    for (const row of data) {
        for (const key of keys) {
            columnarData[key].push(row[key]);
        }
    }

    console.log(`[R Worker] Converted ${data.length} rows to columnar format:`, keys);
    return columnarData;
}

/**
 * Handle dependency retrieval with Reference Item support (mirroring Python worker)
 * @ignore
 * @param {string} depId - Dependency ID
 * @param {Object} dbConfig - Database configuration
 * @returns {Promise&lt;any>} The actual data
 */
async function resolveDependency(depId, dbConfig) {
    let actualDataId = depId;
    const dbName = dbConfig.database || 'hydrocomputeDB';
    const storeName = dbConfig.storeName || 'results';

    try {
        const db = await openDatabase(dbName);

        // Check if it is a reference item in 'settings'
        if (db.objectStoreNames.contains('settings')) {
            const transaction = db.transaction(['settings'], 'readonly');
            const settingsStore = transaction.objectStore('settings');

            const settings = await new Promise((resolve) => {
                const req = settingsStore.get(depId);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });

            if (settings &amp;&amp; (settings.isReference === true || settings.parameters?.source === 'database')) {
                const refId = settings.arguments?.referenceId ||
                    settings.referenceData?.id ||
                    settings.parameters?.referenceId;
                if (refId) {
                    console.log(`Dependency ${depId} is a reference to ${refId}`);
                    actualDataId = refId;
                }
            }
        }
        db.close();
    } catch (e) {
        console.warn(`Error resolving references for ${depId}, using ID as-is.`, e);
    }

    const result = await getDataFromIndexedDB(dbName, storeName, actualDataId);

    if (!result) return null;

    // Return .data if it exists (standard wrap), else result itself
    return (result.data !== undefined) ? result.data : result;
}


/**
 * @description WebR Worker Message Handler
 * Executes R scripts using WebR by evaluating code retrieved from IndexedDB.
 * 
 * Workflow:
 * 1. Receives execution context (funcName, uniqueId, dependencies).
 * 2. Resolves dependencies from IndexedDB (handling Reference Items).
 * 3. Initializes WebR (if not already loaded).
 * 4. Loads required R packages defined in settings.
 * 5. Binds resolved data to the R global environment (as `data_input`).
 * 6. Executes the R code using `webR.evalR`.
 * 7. Captures the result, converts it to JavaScript, and stores it in IndexedDB.
 * 8. Sends completion message and performance metrics back to the main thread.
 * 
 * @param {MessageEvent} e - The message event containing execution details.
 * @param {Object} e.data - The execution data object.
 * @param {string|Object} e.data.funcName - The function/script identifier.
 * @param {string} e.data.uniqueId - Unique ID for the task/result.
 * @param {Array&lt;string>} e.data.dependencies - List of data IDs to load.
 * @param {Object} e.data.dbConfig - Database configuration (database, storeName).
 */
self.onmessage = async (e) => {
    console.log('[R Worker] Message received:', e.data);
    const executionData = e.data;
    performance.mark("start-script");

    // Extract uniqueId - can be direct, nested in funcName, or just funcName string
    const uniqueId = executionData.uniqueId ||
        ((executionData.funcName &amp;&amp; executionData.funcName.id) ? executionData.funcName.id :
            (typeof executionData.funcName === 'string' ? executionData.funcName : null));

    // Dependencies resolution logic
    let dependencies = executionData.dependencies || [];
    if ((!dependencies || dependencies.length === 0) &amp;&amp; executionData.dataIds) {
        // If dataIds is present, use it as dependencies
        // If it's a list, use it. If nested?
        if (Array.isArray(executionData.dataIds)) {
            // Check if it's a list of lists (split data) or simple list of IDs
            if (Array.isArray(executionData.dataIds[0])) {
                dependencies = executionData.dataIds[0];
            } else {
                dependencies = executionData.dataIds;
            }
        } else {
            dependencies = [executionData.dataIds];
        }
    }

    const dbConfig = executionData.dbConfig;
    const funcName = executionData.funcName;
    const id = executionData.id;
    const step = executionData.step;
    const data = executionData.data; // Direct data passing?

    self.postMessage({
        type: 'status',
        itemId: uniqueId,
        status: 'running'
    });

    let result = null;

    try {
        const dbName = dbConfig?.database || 'hydrocomputeDB';

        // 1. Retrieve R Code &amp; Settings
        let rCode = null;
        let requiredPackages = [];
        let scriptId = null;

        if (funcName) {
            scriptId = (typeof funcName === 'string') ? funcName :
                (funcName.id || funcName.name || funcName.functionName);
        }

        console.log(`Script Lookup - funcName:`, funcName, `extracted scriptId:`, scriptId, `uniqueId:`, uniqueId);
        // Fallback to uniqueId if strict mapping implies uniqueId IS the script ID (unlikely for new runs)
        // But for stored tasks, uniqueId might be relevant. Check scriptId first.

        const lookupId = scriptId || uniqueId;

        if (lookupId) {
            try {
                const db = await openDatabase(dbName);
                const settingsStore = db.transaction('settings', 'readonly').objectStore('settings');
                const settings = await new Promise((resolve, reject) => {
                    const req = settingsStore.get(lookupId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
                db.close();

                if (settings) {
                    if (settings.code) rCode = settings.code;
                    if (settings.libraries) {
                        requiredPackages = Array.isArray(settings.libraries) ? settings.libraries : [settings.libraries];
                    }
                    // Handle mixed library formats (strings, objects?)
                    requiredPackages = requiredPackages.map(p => (typeof p === 'string' ? p : p.name || p.toString()));
                }
            } catch (err) {
                console.warn('Could not retrieve settings/code from DB:', err);
            }
        }

        // 2. Retrieve Data (Dependencies)
        let dataInputs = [];
        if (dependencies &amp;&amp; dependencies.length > 0) {
            // Ensure dependencies is an array
            if (!Array.isArray(dependencies)) {
                // If it's a string, wrap it. Spreading string is BAD for IDs.
                dependencies = [dependencies];
            }
            console.log(`Resolving ${dependencies.length} dependencies:`, dependencies);

            dataInputs = await Promise.all(
                dependencies.map(depId => resolveDependency(depId, dbConfig))
            );
            // Validate
            if (dataInputs.some(d => d === null || d === undefined)) {
                throw new Error("One or more dependencies could not be resolved.");
            }
        } else if (data) {
            // Support direct data injection if not DB-based
            dataInputs = Array.isArray(data) ? data : [data];
        }

        // 3. Initialize WebR
        performance.mark("start-function");
        const webR = await getWebR();

        // 4. Install Packages
        if (requiredPackages.length > 0) {
            await loadRPackages(requiredPackages, webR);
        }

        // 5. Bind Data Inputs
        // Determine binding strategy.
        // If 1 input: bind as 'data'
        // If >1 input: bind as 'data1', 'data2'... OR a list 'data'
        // Following Python worker pattern: usually 'data_input' contains the list of inputs
        // Let's bind 'data_input' as a list if multiple, or just the object if single.

        // Actually, consistency with Python worker (which typically passes 'data_input' as list)
        // We will bind 'data_input' as a LIST in R.

        const shelter = await new webR.Shelter();

        // Bind individual items first? No, bind the array directly if possible.
        // WebR JS binding handles arrays well.
        // We want `data_input` in R to be a list where `data_input[[1]]` is the first dep.

        // Preprocess dependencies: Convert Array-of-Objects to Columnar
        console.log('[R Worker] Inspecting dataInputs for conversion:',
            dataInputs.map(d => ({
                isArray: Array.isArray(d),
                length: d?.length,
                firstItemType: typeof d?.[0],
                firstItemIsObject: typeof d?.[0] === 'object',
                firstItemKeys: (d?.[0] &amp;&amp; typeof d?.[0] === 'object') ? Object.keys(d[0]) : null
            }))
        );

        const processedInputs = dataInputs.map(dep => {
            // Check if it's an array of objects
            if (Array.isArray(dep) &amp;&amp; dep.length > 0 &amp;&amp; typeof dep[0] === 'object' &amp;&amp; dep[0] !== null) {
                return toColumnar(dep);
            }
            return dep;
        });

        console.log('[R Worker] Final binding data structure:', JSON.stringify(processedInputs));
        await bindJsToR(processedInputs, 'data_input', webR);

        // 6. Execute R Code
        if (rCode) {
            console.log("Executing R Code...");
            // Ensure R code uses 'data_input'
            // Wrap execution in captureR
            // We expect the script to either return the result directly or assign to 'result' or something?
            // Python worker assumes the script returns something or we parse stdout? 
            // Actually Python settings usually have the return value handling or last expression.

            // We'll capture the return value of the code block.
            // Using evalR instead of captureR to ensure we get an RObject
            const resultRObj = await webR.evalR(rCode, {
                env: webR.objs.globalEnv,
                bind: { data_input: 'data_input' } // Explicit binding if supported or relies on globalEnv?
                // bindJsToR already put it in globalEnv? 
                // bindJsToR likely did `webR.objs.globalEnv.bind("data_input", ...)`
            });

            console.log("R Evaluation Result Object:", resultRObj);

            // Convert back to JS
            try {
                result = await resultRObj.toJs();
            } catch (e) {
                console.warn("toJs() failed, trying values/toArray?", e);
                result = resultRObj; // Fallback
            }

            // Clean up? If we used webR.evalR, we assume we might need to free it?
            // If we used a shelter content, we should use shelter.
        } else {
            throw new Error("No R code provided.");
        }

        // 7. Store Result
        if (dbConfig &amp;&amp; dbConfig.storeName &amp;&amp; result !== null &amp;&amp; uniqueId) {
            const serializableData = await prepareDataForStorage(result);
            await storeResultInIndexedDB(dbConfig.database, dbConfig.storeName, {
                id: uniqueId,
                data: serializableData,
                status: 'completed',
                timestamp: new Date().toISOString()
            });
        }

        shelter.purge();

        // 8. Send Completion
        self.postMessage({
            type: 'status',
            itemId: uniqueId,
            status: 'completed'
        });

        performance.mark("end-function");
        performance.mark("end-script");
        const getPerformance = getPerformanceMeasures();

        self.postMessage({
            id,
            status: 'completed',
            step,
            funcName: funcName ? (funcName.path || funcName) : null,
            results: result,
            ...getPerformance
        });

    } catch (error) {
        console.error('Error executing R function:', error);
        if (uniqueId) {
            self.postMessage({
                type: 'status',
                itemId: uniqueId,
                status: 'error',
                error: error.message
            });
        }
        throw error;
    }
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Jan 12 2026 21:25:10 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
