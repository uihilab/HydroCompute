## Web Assembly Engine
### Introduction
This engine call methods and functions compliant with code compiled into Web Assembly. The code that is being used from WebAssembly is being instantiated depending on the type of language it was compiled on and usually a JavaScript steering file is required (this is automatically created during compilation, see below for more details). 

### Set Up
Upon initialization of the HydroCompute instance, call the engine as:
```javascript
const compute = new hydrocompute("wasm");
``` 
Or if the instance already has a different engine, change it as:
```javascript
compute.setEngine("wasm");
```
Once changed, all the methods and scripts found in the scripts folder will be ready for usage. The general structure used in the compiled code, agnostic of the source language, is having a `main` function calling the required functions. Example in C:

```C
//Definition of functions 
void function1(float *data){...};
void function2(float *data) {...};
//Calling the main function
int main(int argc, char** argv){
if (strcmp(name, "function1") == 0) {
function1(data);
} else if (strcmp(name, "function2") == 0) {
function2(data);
}
...
```
If the main function exists within the script, it is used as the point of interaction between the worker and the script. If it doesn't exist, the function name will be used as the entry point directly. If the user is running scripts outside of the library's available scripts, then it should be specified in the arguments of the run function.

### C Compilation
Compile C code using the following `EMSCRIPTEN` command using the following flags:

```cmd
emcc nameOfCFile.c -O3 -o nameOfCFile.js -s MODULARIZE -s EXPORT_ES6=1 -s ALLOW_MEMORY_GROWTH=1
```
The command will generate two output. files, make sure they are in the same directory when running.

### AssemblyScript Compilation
Whether using `node` or direct compilation with the `npm`, use the `AssemblyScript` command as follows:

```cmd
asc assembly/nameOfASFile.ts -b build/nameOfASFile/optimized.wasm -t build/nameOfASFile/optimized.wat --sourceMap --validate --optimize
```
The command will generate two output. files, make sure they are in the same directory when running.

### Usage
After defining the data that will be used within the compute, with a specific name tag or the one generated by the library, the engine can be used by calling the ```run``` method as follows:

```javascript
compute.run({ 
functions: [collection of functions in array format], 
dataIds: [nametag of data saved in the library in array format]
})
```
Please see examples and homepage for more arguments that can be passed to the run function. After the simulation has finished, the result will be saved in the ```compute.availableResults``` object.

### Best Practices
Web Assembly modules are incredibly versatile and can be used to run different complexity of analysis. However, please consider the following:

* Each compiled module must be accompanied by a mapping mechanism generated by the compiler.
* If contributing new WGSL code scripts, try to create code that is as simple as possible to maximize performance.

### Contribution and Support
Contributing to the WebGPU engine can be done in the following ways:

* Create an issue to submit a feature request or update.
* Create your own WGSL code, following the structure described above, and share it through forks and by submitting a pull request. Before submitting, please ensure that the changes pass unit tests and adhere to the project's code style guidelines.
If you encounter any issues while using the engine, please submit an issue on the project's GitHub page. The team will do their best to resolve it as soon as possible.
